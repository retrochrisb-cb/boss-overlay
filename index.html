<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Boss Overlay â€” Auto Publish</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{--bar-width:420px;--bar-height:36px;--bg:rgba(0,0,0,0.6);--white:#fff}
    html,body{height:100%;margin:0;background:transparent;font-family:system-ui,Arial;color:var(--white)}
    /* Admin */
    #controls{position:absolute;left:12px;top:12px;z-index:90;background:var(--bg);padding:10px;border-radius:8px;max-width:760px}
    #controls input,#controls select,#controls button{margin:6px 6px 6px 0;padding:6px;border-radius:6px;border:0;background:#222;color:#fff}
    #addForm{display:none;background:#111;padding:8px;border-radius:6px;margin-top:6px}
    /* Viewer */
    #viewer{width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding-top:36px;pointer-events:none}
    #boss{max-width:420px;max-height:420px;image-rendering:pixelated;pointer-events:none}
    #healthWrap{width:var(--bar-width);height:var(--bar-height);background:#222;border:4px solid #000;border-radius:6px;overflow:hidden;margin-top:12px;position:relative}
    #healthBar{height:100%;width:100%;background:linear-gradient(90deg,#ff6b6b,#8b0000);transition:width .25s linear}
    #healthPct{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-weight:bold}
    #damageText,#leaderboard,#mvp{margin-top:8px;text-align:center}
    @media (max-width:720px){ :root{--bar-width:320px} }
  </style>
</head>
<body>
  <!-- Admin controls -->
  <div id="controls" aria-hidden="true">
    <div>
      <label>Repo owner</label>
      <input id="ghOwner" type="text" placeholder="retrochrisb-cb" value="retrochrisb-cb" />
      <label>Repo</label>
      <input id="ghRepo" type="text" placeholder="boss-overlay" value="boss-overlay" />
    </div>

    <div>
      <label>GitHub Token</label>
      <input id="ghToken" type="password" placeholder="Paste PAT (repo:contents)" style="width:360px" />
      <button id="saveToken">Save Token</button>
      <button id="clearToken">Clear Token</button>
    </div>

    <div style="margin-top:6px">
      <label>Boss</label>
      <select id="bossSelect"></select>
      <label>Max HP</label>
      <input id="maxHp" type="number" value="1000" min="1" />
    </div>

    <div style="margin-top:6px">
      <button id="prevBtn">Prev</button>
      <button id="nextBtn">Next Boss</button>
      <button id="publishBtn">Publish (local)</button>
      <label style="margin-left:8px"><input id="autoNext" type="checkbox" /> Auto Next</label>
    </div>

    <div style="margin-top:6px">
      <button id="addBtn">Add Boss</button>
      <button id="delBtn">Delete Boss</button>
      <button id="downloadPublished">Download published.json</button>
    </div>

    <div id="addForm">
      <div><label>Name</label><input id="bossName" type="text" /></div>
      <div>
        <label>Normal PNG</label><input id="normalFile" type="file" accept="image/png" />
        <label>Damage PNG</label><input id="damageFile" type="file" accept="image/png" />
      </div>
      <div><button id="saveBtn">Save</button><button id="cancelBtn">Cancel</button></div>
      <div style="font-size:12px;margin-top:6px">Tip: keep PNGs under ~800px for reliable embedding.</div>
    </div>

    <div style="margin-top:8px">
      <label>Published.json URL (viewer)</label>
      <input id="jsonUrl" type="text" style="width:360px" placeholder="https://youruser.github.io/boss-overlay/published.json" />
      <button id="saveJson">Save</button>
    </div>
  </div>

  <!-- Viewer -->
  <div id="viewer" role="presentation">
    <img id="boss" src="" alt="boss" />
    <div id="healthWrap">
      <div id="healthBar"></div>
      <div id="healthPct">100%</div>
    </div>
    <div id="damageText"></div>
    <div id="leaderboard"></div>
    <div id="mvp"></div>
  </div>

<script>
/* ====== Simple overlay with GitHub auto-publish (Option A) ====== */
const KEY_BOSSES = 'auto_bosses';
const KEY_PUBLISHED = 'auto_published';
const KEY_JSON = 'auto_json_url';
const KEY_GHTOKEN = 'auto_github_pat';
const DEFAULT_JSON = (location.origin + location.pathname).replace(/\/$/, '') + '/published.json';
const TRANSPARENT = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=';

const IS_ADMIN = new URL(location.href).searchParams.get('admin') === '1';
if (!IS_ADMIN) { const c = document.getElementById('controls'); if (c) c.style.display = 'none'; }

window.addEventListener('DOMContentLoaded', async () => {
  // Elements
  const bossImg = document.getElementById('boss');
  const healthBar = document.getElementById('healthBar');
  const healthPct = document.getElementById('healthPct');
  const damageText = document.getElementById('damageText');
  const leaderboard = document.getElementById('leaderboard');
  const mvp = document.getElementById('mvp');

  // Admin elements
  const controls = document.getElementById('controls');
  const ghOwner = document.getElementById('ghOwner');
  const ghRepo = document.getElementById('ghRepo');
  const ghTokenInput = document.getElementById('ghToken');
  const saveTokenBtn = document.getElementById('saveToken');
  const clearTokenBtn = document.getElementById('clearToken');

  const bossSelect = document.getElementById('bossSelect');
  const maxHp = document.getElementById('maxHp');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const publishBtn = document.getElementById('publishBtn');
  const autoNext = document.getElementById('autoNext');
  const addBtn = document.getElementById('addBtn');
  const delBtn = document.getElementById('delBtn');
  const addForm = document.getElementById('addForm');
  const bossName = document.getElementById('bossName');
  const normalFile = document.getElementById('normalFile');
  const damageFile = document.getElementById('damageFile');
  const saveBtn = document.getElementById('saveBtn');
  const cancelBtn = document.getElementById('cancelBtn');
  const downloadPublished = document.getElementById('downloadPublished');
  const jsonUrl = document.getElementById('jsonUrl');
  const saveJson = document.getElementById('saveJson');

  // State
  let bosses = JSON.parse(localStorage.getItem(KEY_BOSSES) || '{}');
  let published = null;
  let bossState = { health: 1000, max: 1000 };
  let damageLog = {};
  let lastTs = null;

  // Helpers
  function saveBosses(){ localStorage.setItem(KEY_BOSSES, JSON.stringify(bosses)); }
  function getJsonUrl(){ const v = localStorage.getItem(KEY_JSON) || jsonUrl.value || DEFAULT_JSON; if (v.endsWith('/')) return v + 'published.json'; if (v.endsWith('published.json')) return v; if (!v.includes('published.json')) return v + (v.includes('?') ? '&' : '/') + 'published.json'; return v; }
  function setHealthUI(){ const pct = Math.max(0, Math.round((bossState.health / bossState.max) * 100)); healthBar.style.width = pct + '%'; healthPct.textContent = pct + '%'; }
  function updateLeaderboard(){ const arr = Object.entries(damageLog).sort((a,b)=>b[1]-a[1]); leaderboard.innerHTML = arr.length ? arr.map((r,i)=>`${i+1}. ${r[0]}: ${r[1]} dmg`).join('<br>') : 'No damage yet'; }
  function showMVP(){ const arr = Object.entries(damageLog).sort((a,b)=>b[1]-a[1]); mvp.innerHTML = arr.length ? `ðŸ† MVP: ${arr[0][0]} â€” ${arr[0][1]} dmg` : 'No contributors'; }

  function getNormalSrc(key){ const b = bosses[key]||{}; return b.normalData||b.normalUrl||TRANSPARENT; }
  function getDamageSrc(key){ const b = bosses[key]||{}; return b.damageData||b.damageUrl||getNormalSrc(key); }

  async function fileToDataUrl(file){ return new Promise((res,rej)=>{ try{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=e=>rej(e); r.readAsDataURL(file);}catch(e){rej(e);} }); }

  function populateSelect(){
    bossSelect.innerHTML = '';
    const keys = Object.keys(bosses);
    for (const k of keys){ const o = document.createElement('option'); o.value = k; o.textContent = (bosses[k].name||k).replace(/_/g,' '); bossSelect.appendChild(o); }
    if (keys.length) bossSelect.value = keys[0];
  }

  function loadPublished(p){
    if (!p) return;
    published = p;
    bossState.max = p.maxHealth || 1000;
    bossState.health = bossState.max;
    damageLog = {};
    lastTs = p.timestamp || Date.now();
    bossImg.src = p.normalData || p.normalUrl || TRANSPARENT;
    setHealthUI(); updateLeaderboard(); mvp.textContent = '';
  }

  async function fetchPublishedOnce(){
    const url = getJsonUrl();
    try {
      const r = await fetch(url, {cache:'no-store'});
      if (!r.ok) return;
      const j = await r.json();
      if (j && j.timestamp) loadPublished(j);
    } catch(e){ console.warn('published.json fetch failed', e); }
  }

  async function pollPublished(interval=5000){
    if (IS_ADMIN) return;
    const url = getJsonUrl();
    try {
      const r = await fetch(url, {cache:'no-store'});
      if (!r.ok) return;
      const j = await r.json();
      if (j && j.timestamp && j.timestamp !== lastTs) loadPublished(j);
    } catch(e){}
    setTimeout(()=>pollPublished(interval), interval);
  }

  function applyDamage(amount, user='Viewer', source='Event'){
    if (bossState.health <= 0) return;
    bossState.health = Math.max(0, bossState.health - amount);
    damageLog[user] = (damageLog[user]||0) + amount;
    setHealthUI();
    damageText.textContent = `${user} dealt ${amount} damage with ${source}!`;
    setTimeout(()=>{ if (bossState.health>0) damageText.textContent=''; }, 2000);
    try {
      const sel = bossSelect.value;
      const dmg = published ? (published.damageData||published.damageUrl) : getDamageSrc(sel);
      const norm = published ? (published.normalData||published.normalUrl) : getNormalSrc(sel);
      bossImg.src = dmg || norm || TRANSPARENT;
      setTimeout(()=>{ if (bossState.health>0) bossImg.src = norm || TRANSPARENT; }, 500);
    } catch(e){}
    updateLeaderboard();
    if (bossState.health === 0){
      setTimeout(()=>{ showMVP(); if (IS_ADMIN && autoNext.checked) nextBoss(true); }, 800);
    }
  }

  /* GitHub upload helper */
  async function uploadPublishedToGitHub({ owner, repo, path='published.json', token, contentObj, commitMessage='Update published.json' }) {
    if (!token) throw new Error('GitHub token required');
    const apiBase = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`;
    let sha = null;
    try {
      const getRes = await fetch(apiBase, { method: 'GET', headers: { Authorization: 'token ' + token, Accept: 'application/vnd.github.v3+json' }});
      if (getRes.ok) { const getJson = await getRes.json(); sha = getJson.sha; }
      else if (getRes.status !== 404) { const txt = await getRes.text(); console.warn('GitHub GET returned', getRes.status, txt); }
    } catch (e) { console.warn('GitHub GET failed', e); }
    const jsonText = JSON.stringify(contentObj, null, 2);
    const b64 = btoa(unescape(encodeURIComponent(jsonText)));
    const body = { message: commitMessage, content: b64, committer: { name: "Overlay Admin", email: "overlay@example.com" } };
    if (sha) body.sha = sha;
    const putRes = await fetch(apiBase, { method: 'PUT', headers: { Authorization: 'token ' + token, Accept: 'application/vnd.github.v3+json' }, body: JSON.stringify(body) });
    if (!putRes.ok) {
      const errText = await putRes.text();
      throw new Error('GitHub upload failed: ' + putRes.status + ' ' + errText);
    }
    return await putRes.json();
  }

  /* Admin bindings */
  populateSelect();

  // Token save/clear
  saveTokenBtn.addEventListener('click', ()=> {
    const t = ghTokenInput.value.trim();
    if (!t) return alert('Paste a GitHub PAT with repo:contents scope');
    localStorage.setItem(KEY_GHTOKEN, t);
    alert('Token saved locally (browser).');
    ghTokenInput.value = '';
  });
  clearTokenBtn.addEventListener('click', ()=> { localStorage.removeItem(KEY_GHTOKEN); alert('Token cleared'); });

  addBtn.addEventListener('click', ()=> addForm.style.display = 'block');
  cancelBtn.addEventListener('click', ()=> addForm.style.display = 'none');

  saveBtn.addEventListener('click', async ()=>{
    const name = (bossName.value||'').trim();
    if (!name) { alert('Enter a name'); return; }
    const key = name.replace(/\s+/g,'_').toLowerCase();
    try {
      let n = null, d = null;
      if (normalFile.files && normalFile.files[0]) n = await fileToDataUrl(normalFile.files[0]);
      if (damageFile.files && damageFile.files[0]) d = await fileToDataUrl(damageFile.files[0]);
      bosses[key] = bosses[key] || {};
      bosses[key].name = name;
      if (n) bosses[key].normalData = n;
      if (d) bosses[key].damageData = d;
      saveBosses(); populateSelect(); addForm.style.display = 'none';
      bossName.value=''; normalFile.value=''; damageFile.value='';
      alert('Saved locally. Select and Publish or Next Boss.');
    } catch(e){ console.error(e); alert('Failed to save. Try smaller PNGs.'); }
  });

  delBtn.addEventListener('click', ()=> {
    const k = bossSelect.value; if (!k) { alert('No boss'); return; }
    if (!confirm('Delete ' + (bosses[k].name||k) + '?')) return;
    delete bosses[k]; saveBosses(); populateSelect();
  });

  publishBtn.addEventListener('click', ()=> {
    const k = bossSelect.value; if (!k) { alert('No boss selected'); return; }
    const payload = { name: bosses[k].name||k, normalData: bosses[k].normalData||bosses[k].normalUrl||null, damageData: bosses[k].damageData||bosses[k].damageUrl||null, maxHealth: parseInt(maxHp.value,10)||1000, timestamp: Date.now() };
    localStorage.setItem(KEY_PUBLISHED, JSON.stringify(payload));
    loadPublished(payload);
    alert('Published locally. Use "Upload to GitHub" to push to Pages automatically.');
  });

  // Next boss: publish locally and attempt auto-upload if token present
  async function nextBoss(auto=false){
    const keys = Object.keys(bosses);
    if (!keys.length){ alert('No bosses'); return; }
    const cur = bossSelect.value;
    let idx = keys.indexOf(cur);
    idx = (idx + 1) % keys.length;
    bossSelect.value = keys[idx];
    const payload = { name: bosses[keys[idx]].name||keys[idx], normalData: bosses[keys[idx]].normalData||bosses[keys[idx]].normalUrl||null, damageData: bosses[keys[idx]].damageData||bosses[keys[idx]].damageUrl||null, maxHealth: parseInt(maxHp.value,10)||1000, timestamp: Date.now() };
    localStorage.setItem(KEY_PUBLISHED, JSON.stringify(payload));
    loadPublished(payload);
    // attempt auto-upload if token exists
    const token = localStorage.getItem(KEY_GHTOKEN);
    const owner = ghOwner.value.trim() || ghOwner.placeholder;
    const repo = ghRepo.value.trim() || ghRepo.placeholder;
    if (token) {
      try {
        await uploadPublishedToGitHub({ owner, repo, token, contentObj: payload, commitMessage: `Publish ${payload.name} @ ${Date.now()}` });
        alert('published.json uploaded to GitHub Pages. Viewer will pick it up shortly.');
      } catch (err) {
        console.error(err);
        alert('Auto-upload failed: ' + err.message + '. published.json saved locally.');
        downloadPublishedJson(); // fallback: download so user can upload manually
      }
    } else {
      downloadPublishedJson();
      if (!auto) alert('Published locally and downloaded published.json for manual upload.');
    }
  }
  nextBtn.addEventListener('click', ()=> nextBoss(false));

  prevBtn.addEventListener('click', ()=> {
    const keys = Object.keys(bosses); if (!keys.length) return;
    const cur = bossSelect.value; let idx = keys.indexOf(cur); idx = (idx - 1 + keys.length) % keys.length; bossSelect.value = keys[idx];
  });

  function downloadPublishedJson(){
    const pub = localStorage.getItem(KEY_PUBLISHED);
    if (!pub){ alert('Nothing published'); return; }
    const blob = new Blob([JSON.stringify(JSON.parse(pub),null,2)], {type:'application/json'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'published.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(a.href);
  }
  downloadPublished.addEventListener('click', downloadPublishedJson);

  saveJson.addEventListener('click', ()=> { localStorage.setItem(KEY_JSON, jsonUrl.value || DEFAULT_JSON); alert('Saved'); });

  // Initial viewer load
  await fetchPublishedOnce();
  if (!published){
    const localPub = localStorage.getItem(KEY_PUBLISHED);
    if (localPub) try{ loadPublished(JSON.parse(localPub)); }catch(e){}
  }
  if (!published){
    const keys = Object.keys(bosses);
    if (keys.length){ bossImg.src = bosses[keys[0]].normalData||bosses[keys[0]].normalUrl||TRANSPARENT; bossState.max = parseInt(maxHp.value,10)||1000; bossState.health = bossState.max; setHealthUI(); }
    else { bossImg.src = TRANSPARENT; bossState.max = 1000; bossState.health = 1000; setHealthUI(); }
  }

  // Start polling in viewer mode
  if (!IS_ADMIN) setTimeout(()=>pollPublished(5000), 1500);

  // Expose debug helpers
  window.__autoBoss = { bosses: ()=>JSON.parse(localStorage.getItem(KEY_BOSSES)||'{}'), published: ()=>JSON.parse(localStorage.getItem(KEY_PUBLISHED)||'null'), applyDamage };

  // Admin convenience: click boss image to deal small damage
  if (IS_ADMIN) bossImg.addEventListener('click', ()=> applyDamage(5,'Admin','Click'));
});
</script>
</body>
</html>









